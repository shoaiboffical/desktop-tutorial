{"ast":null,"code":"import { getAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/addresses.js\";\nimport { keccak256, Signature, SigningKey } from \"../crypto/index.js\";\nimport { concat, decodeRlp, encodeRlp, getBytes, getBigInt, getNumber, hexlify, assert, assertArgument, isHexString, toBeArray, zeroPadValue } from \"../utils/index.js\";\nimport { accessListify } from \"./accesslist.js\";\nimport { recoverAddress } from \"./address.js\";\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction handleAddress(value) {\n  if (value === \"0x\") {\n    return null;\n  }\n  return getAddress(value);\n}\nfunction handleAccessList(value, param) {\n  try {\n    return accessListify(value);\n  } catch (error) {\n    assertArgument(false, error.message, param, value);\n  }\n}\nfunction handleNumber(_value, param) {\n  if (_value === \"0x\") {\n    return 0;\n  }\n  return getNumber(_value, param);\n}\nfunction handleUint(_value, param) {\n  if (_value === \"0x\") {\n    return BN_0;\n  }\n  const value = getBigInt(_value, param);\n  assertArgument(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n  return value;\n}\nfunction formatNumber(_value, name) {\n  const value = getBigInt(_value, \"value\");\n  const result = toBeArray(value);\n  assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);\n  return result;\n}\nfunction formatAccessList(value) {\n  return accessListify(value).map(set => [set.address, set.storageKeys]);\n}\nfunction formatHashes(value, param) {\n  assertArgument(Array.isArray(value), `invalid ${param}`, \"value\", value);\n  for (let i = 0; i < value.length; i++) {\n    assertArgument(isHexString(value[i], 32), \"invalid ${ param } hash\", `value[${i}]`, value[i]);\n  }\n  return value;\n}\nfunction _parseLegacy(data) {\n  const fields = decodeRlp(data);\n  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n  const tx = {\n    type: 0,\n    nonce: handleNumber(fields[0], \"nonce\"),\n    gasPrice: handleUint(fields[1], \"gasPrice\"),\n    gasLimit: handleUint(fields[2], \"gasLimit\"),\n    to: handleAddress(fields[3]),\n    value: handleUint(fields[4], \"value\"),\n    data: hexlify(fields[5]),\n    chainId: BN_0\n  };\n  // Legacy unsigned transaction\n  if (fields.length === 6) {\n    return tx;\n  }\n  const v = handleUint(fields[6], \"v\");\n  const r = handleUint(fields[7], \"r\");\n  const s = handleUint(fields[8], \"s\");\n  if (r === BN_0 && s === BN_0) {\n    // EIP-155 unsigned transaction\n    tx.chainId = v;\n  } else {\n    // Compute the EIP-155 chain ID (or 0 for legacy)\n    let chainId = (v - BN_35) / BN_2;\n    if (chainId < BN_0) {\n      chainId = BN_0;\n    }\n    tx.chainId = chainId;\n    // Signed Legacy Transaction\n    assertArgument(chainId !== BN_0 || v === BN_27 || v === BN_28, \"non-canonical legacy v\", \"v\", fields[6]);\n    tx.signature = Signature.from({\n      r: zeroPadValue(fields[7], 32),\n      s: zeroPadValue(fields[8], 32),\n      v\n    });\n    tx.hash = keccak256(data);\n  }\n  return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n  const fields = [formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.gasPrice || 0, \"gasPrice\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || \"0x\", formatNumber(tx.value, \"value\"), tx.data];\n  let chainId = BN_0;\n  if (tx.chainId != BN_0) {\n    // A chainId was provided; if non-zero we'll use EIP-155\n    chainId = getBigInt(tx.chainId, \"tx.chainId\");\n    // We have a chainId in the tx and an EIP-155 v in the signature,\n    // make sure they agree with each other\n    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n  } else if (tx.signature) {\n    // No explicit chainId, but EIP-155 have a derived implicit chainId\n    const legacy = tx.signature.legacyChainId;\n    if (legacy != null) {\n      chainId = legacy;\n    }\n  }\n  // Requesting an unsigned transaction\n  if (!sig) {\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== BN_0) {\n      fields.push(toBeArray(chainId));\n      fields.push(\"0x\");\n      fields.push(\"0x\");\n    }\n    return encodeRlp(fields);\n  }\n  // @TODO: We should probably check that tx.signature, chainId, and sig\n  //        match but that logic could break existing code, so schedule\n  //        this for the next major bump.\n  // Compute the EIP-155 v\n  let v = BigInt(27 + sig.yParity);\n  if (chainId !== BN_0) {\n    v = Signature.getChainIdV(chainId, sig.v);\n  } else if (BigInt(sig.v) !== v) {\n    assertArgument(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n  }\n  // Add the signature\n  fields.push(toBeArray(v));\n  fields.push(toBeArray(sig.r));\n  fields.push(toBeArray(sig.s));\n  return encodeRlp(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n  let yParity;\n  try {\n    yParity = handleNumber(fields[0], \"yParity\");\n    if (yParity !== 0 && yParity !== 1) {\n      throw new Error(\"bad yParity\");\n    }\n  } catch (error) {\n    assertArgument(false, \"invalid yParity\", \"yParity\", fields[0]);\n  }\n  const r = zeroPadValue(fields[1], 32);\n  const s = zeroPadValue(fields[2], 32);\n  const signature = Signature.from({\n    r,\n    s,\n    yParity\n  });\n  tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n  const fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", hexlify(data));\n  const tx = {\n    type: 2,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n    maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n    gasPrice: null,\n    gasLimit: handleUint(fields[4], \"gasLimit\"),\n    to: handleAddress(fields[5]),\n    value: handleUint(fields[6], \"value\"),\n    data: hexlify(fields[7]),\n    accessList: handleAccessList(fields[8], \"accessList\")\n  };\n  // Unsigned EIP-1559 Transaction\n  if (fields.length === 9) {\n    return tx;\n  }\n  tx.hash = keccak256(data);\n  _parseEipSignature(tx, fields.slice(9));\n  return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n  const fields = [formatNumber(tx.chainId, \"chainId\"), formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || \"0x\", formatNumber(tx.value, \"value\"), tx.data, formatAccessList(tx.accessList || [])];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"yParity\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x02\", encodeRlp(fields)]);\n}\nfunction _parseEip2930(data) {\n  const fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", hexlify(data));\n  const tx = {\n    type: 1,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    gasPrice: handleUint(fields[2], \"gasPrice\"),\n    gasLimit: handleUint(fields[3], \"gasLimit\"),\n    to: handleAddress(fields[4]),\n    value: handleUint(fields[5], \"value\"),\n    data: hexlify(fields[6]),\n    accessList: handleAccessList(fields[7], \"accessList\")\n  };\n  // Unsigned EIP-2930 Transaction\n  if (fields.length === 8) {\n    return tx;\n  }\n  tx.hash = keccak256(data);\n  _parseEipSignature(tx, fields.slice(8));\n  return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n  const fields = [formatNumber(tx.chainId, \"chainId\"), formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.gasPrice || 0, \"gasPrice\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || \"0x\", formatNumber(tx.value, \"value\"), tx.data, formatAccessList(tx.accessList || [])];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x01\", encodeRlp(fields)]);\n}\nfunction _parseEip4844(data) {\n  const fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), \"invalid field count for transaction type: 3\", \"data\", hexlify(data));\n  const tx = {\n    type: 3,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n    maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n    gasPrice: null,\n    gasLimit: handleUint(fields[4], \"gasLimit\"),\n    to: handleAddress(fields[5]),\n    value: handleUint(fields[6], \"value\"),\n    data: hexlify(fields[7]),\n    accessList: handleAccessList(fields[8], \"accessList\"),\n    maxFeePerBlobGas: handleUint(fields[9], \"maxFeePerBlobGas\"),\n    blobVersionedHashes: fields[10]\n  };\n  assertArgument(tx.to != null, \"invalid address for transaction type: 3\", \"data\", data);\n  assertArgument(Array.isArray(tx.blobVersionedHashes), \"invalid blobVersionedHashes: must be an array\", \"data\", data);\n  for (let i = 0; i < tx.blobVersionedHashes.length; i++) {\n    assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, \"data\", data);\n  }\n  // Unsigned EIP-4844 Transaction\n  if (fields.length === 11) {\n    return tx;\n  }\n  tx.hash = keccak256(data);\n  _parseEipSignature(tx, fields.slice(11));\n  return tx;\n}\nfunction _serializeEip4844(tx, sig) {\n  const fields = [formatNumber(tx.chainId, \"chainId\"), formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || ZeroAddress, formatNumber(tx.value, \"value\"), tx.data, formatAccessList(tx.accessList || []), formatNumber(tx.maxFeePerBlobGas || 0, \"maxFeePerBlobGas\"), formatHashes(tx.blobVersionedHashes || [], \"blobVersionedHashes\")];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"yParity\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x03\", encodeRlp(fields)]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */\nexport class Transaction {\n  #type;\n  #to;\n  #data;\n  #nonce;\n  #gasLimit;\n  #gasPrice;\n  #maxPriorityFeePerGas;\n  #maxFeePerGas;\n  #value;\n  #chainId;\n  #sig;\n  #accessList;\n  #maxFeePerBlobGas;\n  #blobVersionedHashes;\n  /**\n   *  The transaction type.\n   *\n   *  If null, the type will be automatically inferred based on\n   *  explicit properties.\n   */\n  get type() {\n    return this.#type;\n  }\n  set type(value) {\n    switch (value) {\n      case null:\n        this.#type = null;\n        break;\n      case 0:\n      case \"legacy\":\n        this.#type = 0;\n        break;\n      case 1:\n      case \"berlin\":\n      case \"eip-2930\":\n        this.#type = 1;\n        break;\n      case 2:\n      case \"london\":\n      case \"eip-1559\":\n        this.#type = 2;\n        break;\n      case 3:\n      case \"cancun\":\n      case \"eip-4844\":\n        this.#type = 3;\n        break;\n      default:\n        assertArgument(false, \"unsupported transaction type\", \"type\", value);\n    }\n  }\n  /**\n   *  The name of the transaction type.\n   */\n  get typeName() {\n    switch (this.type) {\n      case 0:\n        return \"legacy\";\n      case 1:\n        return \"eip-2930\";\n      case 2:\n        return \"eip-1559\";\n      case 3:\n        return \"eip-4844\";\n    }\n    return null;\n  }\n  /**\n   *  The ``to`` address for the transaction or ``null`` if the\n   *  transaction is an ``init`` transaction.\n   */\n  get to() {\n    const value = this.#to;\n    if (value == null && this.type === 3) {\n      return ZeroAddress;\n    }\n    return value;\n  }\n  set to(value) {\n    this.#to = value == null ? null : getAddress(value);\n  }\n  /**\n   *  The transaction nonce.\n   */\n  get nonce() {\n    return this.#nonce;\n  }\n  set nonce(value) {\n    this.#nonce = getNumber(value, \"value\");\n  }\n  /**\n   *  The gas limit.\n   */\n  get gasLimit() {\n    return this.#gasLimit;\n  }\n  set gasLimit(value) {\n    this.#gasLimit = getBigInt(value);\n  }\n  /**\n   *  The gas price.\n   *\n   *  On legacy networks this defines the fee that will be paid. On\n   *  EIP-1559 networks, this should be ``null``.\n   */\n  get gasPrice() {\n    const value = this.#gasPrice;\n    if (value == null && (this.type === 0 || this.type === 1)) {\n      return BN_0;\n    }\n    return value;\n  }\n  set gasPrice(value) {\n    this.#gasPrice = value == null ? null : getBigInt(value, \"gasPrice\");\n  }\n  /**\n   *  The maximum priority fee per unit of gas to pay. On legacy\n   *  networks this should be ``null``.\n   */\n  get maxPriorityFeePerGas() {\n    const value = this.#maxPriorityFeePerGas;\n    if (value == null) {\n      if (this.type === 2 || this.type === 3) {\n        return BN_0;\n      }\n      return null;\n    }\n    return value;\n  }\n  set maxPriorityFeePerGas(value) {\n    this.#maxPriorityFeePerGas = value == null ? null : getBigInt(value, \"maxPriorityFeePerGas\");\n  }\n  /**\n   *  The maximum total fee per unit of gas to pay. On legacy\n   *  networks this should be ``null``.\n   */\n  get maxFeePerGas() {\n    const value = this.#maxFeePerGas;\n    if (value == null) {\n      if (this.type === 2 || this.type === 3) {\n        return BN_0;\n      }\n      return null;\n    }\n    return value;\n  }\n  set maxFeePerGas(value) {\n    this.#maxFeePerGas = value == null ? null : getBigInt(value, \"maxFeePerGas\");\n  }\n  /**\n   *  The transaction data. For ``init`` transactions this is the\n   *  deployment code.\n   */\n  get data() {\n    return this.#data;\n  }\n  set data(value) {\n    this.#data = hexlify(value);\n  }\n  /**\n   *  The amount of ether (in wei) to send in this transactions.\n   */\n  get value() {\n    return this.#value;\n  }\n  set value(value) {\n    this.#value = getBigInt(value, \"value\");\n  }\n  /**\n   *  The chain ID this transaction is valid on.\n   */\n  get chainId() {\n    return this.#chainId;\n  }\n  set chainId(value) {\n    this.#chainId = getBigInt(value);\n  }\n  /**\n   *  If signed, the signature for this transaction.\n   */\n  get signature() {\n    return this.#sig || null;\n  }\n  set signature(value) {\n    this.#sig = value == null ? null : Signature.from(value);\n  }\n  /**\n   *  The access list.\n   *\n   *  An access list permits discounted (but pre-paid) access to\n   *  bytecode and state variable access within contract execution.\n   */\n  get accessList() {\n    const value = this.#accessList || null;\n    if (value == null) {\n      if (this.type === 1 || this.type === 2 || this.type === 3) {\n        // @TODO: in v7, this should assign the value or become\n        // a live object itself, otherwise mutation is inconsistent\n        return [];\n      }\n      return null;\n    }\n    return value;\n  }\n  set accessList(value) {\n    this.#accessList = value == null ? null : accessListify(value);\n  }\n  /**\n   *  The max fee per blob gas for Cancun transactions.\n   */\n  get maxFeePerBlobGas() {\n    const value = this.#maxFeePerBlobGas;\n    if (value == null && this.type === 3) {\n      return BN_0;\n    }\n    return value;\n  }\n  set maxFeePerBlobGas(value) {\n    this.#maxFeePerBlobGas = value == null ? null : getBigInt(value, \"maxFeePerBlobGas\");\n  }\n  /**\n   *  The BLOB versioned hashes for Cancun transactions.\n   */\n  get blobVersionedHashes() {\n    // @TODO: Mutation is inconsistent; if unset, the returned value\n    // cannot mutate the object, if set it can\n    let value = this.#blobVersionedHashes;\n    if (value == null && this.type === 3) {\n      return [];\n    }\n    return value;\n  }\n  set blobVersionedHashes(value) {\n    if (value != null) {\n      assertArgument(Array.isArray(value), \"blobVersionedHashes must be an Array\", \"value\", value);\n      value = value.slice();\n      for (let i = 0; i < value.length; i++) {\n        assertArgument(isHexString(value[i], 32), \"invalid blobVersionedHash\", `value[${i}]`, value[i]);\n      }\n    }\n    this.#blobVersionedHashes = value;\n  }\n  /**\n   *  Creates a new Transaction with default values.\n   */\n  constructor() {\n    this.#type = null;\n    this.#to = null;\n    this.#nonce = 0;\n    this.#gasLimit = BN_0;\n    this.#gasPrice = null;\n    this.#maxPriorityFeePerGas = null;\n    this.#maxFeePerGas = null;\n    this.#data = \"0x\";\n    this.#value = BN_0;\n    this.#chainId = BN_0;\n    this.#sig = null;\n    this.#accessList = null;\n    this.#maxFeePerBlobGas = null;\n    this.#blobVersionedHashes = null;\n  }\n  /**\n   *  The transaction hash, if signed. Otherwise, ``null``.\n   */\n  get hash() {\n    if (this.signature == null) {\n      return null;\n    }\n    return keccak256(this.serialized);\n  }\n  /**\n   *  The pre-image hash of this transaction.\n   *\n   *  This is the digest that a [[Signer]] must sign to authorize\n   *  this transaction.\n   */\n  get unsignedHash() {\n    return keccak256(this.unsignedSerialized);\n  }\n  /**\n   *  The sending address, if signed. Otherwise, ``null``.\n   */\n  get from() {\n    if (this.signature == null) {\n      return null;\n    }\n    return recoverAddress(this.unsignedHash, this.signature);\n  }\n  /**\n   *  The public key of the sender, if signed. Otherwise, ``null``.\n   */\n  get fromPublicKey() {\n    if (this.signature == null) {\n      return null;\n    }\n    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n  }\n  /**\n   *  Returns true if signed.\n   *\n   *  This provides a Type Guard that properties requiring a signed\n   *  transaction are non-null.\n   */\n  isSigned() {\n    return this.signature != null;\n  }\n  /**\n   *  The serialized transaction.\n   *\n   *  This throws if the transaction is unsigned. For the pre-image,\n   *  use [[unsignedSerialized]].\n   */\n  get serialized() {\n    assert(this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", {\n      operation: \".serialized\"\n    });\n    switch (this.inferType()) {\n      case 0:\n        return _serializeLegacy(this, this.signature);\n      case 1:\n        return _serializeEip2930(this, this.signature);\n      case 2:\n        return _serializeEip1559(this, this.signature);\n      case 3:\n        return _serializeEip4844(this, this.signature);\n    }\n    assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n      operation: \".serialized\"\n    });\n  }\n  /**\n   *  The transaction pre-image.\n   *\n   *  The hash of this is the digest which needs to be signed to\n   *  authorize this transaction.\n   */\n  get unsignedSerialized() {\n    switch (this.inferType()) {\n      case 0:\n        return _serializeLegacy(this);\n      case 1:\n        return _serializeEip2930(this);\n      case 2:\n        return _serializeEip1559(this);\n      case 3:\n        return _serializeEip4844(this);\n    }\n    assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n      operation: \".unsignedSerialized\"\n    });\n  }\n  /**\n   *  Return the most \"likely\" type; currently the highest\n   *  supported transaction type.\n   */\n  inferType() {\n    const types = this.inferTypes();\n    // Prefer London (EIP-1559) over Cancun (BLOb)\n    if (types.indexOf(2) >= 0) {\n      return 2;\n    }\n    // Return the highest inferred type\n    return types.pop();\n  }\n  /**\n   *  Validates the explicit properties and returns a list of compatible\n   *  transaction types.\n   */\n  inferTypes() {\n    // Checks that there are no conflicting properties set\n    const hasGasPrice = this.gasPrice != null;\n    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;\n    const hasAccessList = this.accessList != null;\n    const hasBlob = this.#maxFeePerBlobGas != null || this.#blobVersionedHashes;\n    //if (hasGasPrice && hasFee) {\n    //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n    //}\n    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n      assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", {\n        value: this\n      });\n    }\n    //if (this.type === 2 && hasGasPrice) {\n    //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n    //}\n    assert(!hasFee || this.type !== 0 && this.type !== 1, \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", {\n      value: this\n    });\n    assert(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", {\n      value: this\n    });\n    const types = [];\n    // Explicit type\n    if (this.type != null) {\n      types.push(this.type);\n    } else {\n      if (hasFee) {\n        types.push(2);\n      } else if (hasGasPrice) {\n        types.push(1);\n        if (!hasAccessList) {\n          types.push(0);\n        }\n      } else if (hasAccessList) {\n        types.push(1);\n        types.push(2);\n      } else if (hasBlob && this.to) {\n        types.push(3);\n      } else {\n        types.push(0);\n        types.push(1);\n        types.push(2);\n        types.push(3);\n      }\n    }\n    types.sort();\n    return types;\n  }\n  /**\n   *  Returns true if this transaction is a legacy transaction (i.e.\n   *  ``type === 0``).\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isLegacy() {\n    return this.type === 0;\n  }\n  /**\n   *  Returns true if this transaction is berlin hardform transaction (i.e.\n   *  ``type === 1``).\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isBerlin() {\n    return this.type === 1;\n  }\n  /**\n   *  Returns true if this transaction is london hardform transaction (i.e.\n   *  ``type === 2``).\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isLondon() {\n    return this.type === 2;\n  }\n  /**\n   *  Returns true if this transaction is an [[link-eip-4844]] BLOB\n   *  transaction.\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isCancun() {\n    return this.type === 3;\n  }\n  /**\n   *  Create a copy of this transaciton.\n   */\n  clone() {\n    return Transaction.from(this);\n  }\n  /**\n   *  Return a JSON-friendly object.\n   */\n  toJSON() {\n    const s = v => {\n      if (v == null) {\n        return null;\n      }\n      return v.toString();\n    };\n    return {\n      type: this.type,\n      to: this.to,\n      //            from: this.from,\n      data: this.data,\n      nonce: this.nonce,\n      gasLimit: s(this.gasLimit),\n      gasPrice: s(this.gasPrice),\n      maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n      maxFeePerGas: s(this.maxFeePerGas),\n      value: s(this.value),\n      chainId: s(this.chainId),\n      sig: this.signature ? this.signature.toJSON() : null,\n      accessList: this.accessList\n    };\n  }\n  /**\n   *  Create a **Transaction** from a serialized transaction or a\n   *  Transaction-like object.\n   */\n  static from(tx) {\n    if (tx == null) {\n      return new Transaction();\n    }\n    if (typeof tx === \"string\") {\n      const payload = getBytes(tx);\n      if (payload[0] >= 0x7f) {\n        // @TODO: > vs >= ??\n        return Transaction.from(_parseLegacy(payload));\n      }\n      switch (payload[0]) {\n        case 1:\n          return Transaction.from(_parseEip2930(payload));\n        case 2:\n          return Transaction.from(_parseEip1559(payload));\n        case 3:\n          return Transaction.from(_parseEip4844(payload));\n      }\n      assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"from\"\n      });\n    }\n    const result = new Transaction();\n    if (tx.type != null) {\n      result.type = tx.type;\n    }\n    if (tx.to != null) {\n      result.to = tx.to;\n    }\n    if (tx.nonce != null) {\n      result.nonce = tx.nonce;\n    }\n    if (tx.gasLimit != null) {\n      result.gasLimit = tx.gasLimit;\n    }\n    if (tx.gasPrice != null) {\n      result.gasPrice = tx.gasPrice;\n    }\n    if (tx.maxPriorityFeePerGas != null) {\n      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n    }\n    if (tx.maxFeePerGas != null) {\n      result.maxFeePerGas = tx.maxFeePerGas;\n    }\n    if (tx.maxFeePerBlobGas != null) {\n      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;\n    }\n    if (tx.data != null) {\n      result.data = tx.data;\n    }\n    if (tx.value != null) {\n      result.value = tx.value;\n    }\n    if (tx.chainId != null) {\n      result.chainId = tx.chainId;\n    }\n    if (tx.signature != null) {\n      result.signature = Signature.from(tx.signature);\n    }\n    if (tx.accessList != null) {\n      result.accessList = tx.accessList;\n    }\n    if (tx.blobVersionedHashes != null) {\n      result.blobVersionedHashes = tx.blobVersionedHashes;\n    }\n    if (tx.hash != null) {\n      assertArgument(result.isSigned(), \"unsigned transaction cannot define hash\", \"tx\", tx);\n      assertArgument(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n    }\n    if (tx.from != null) {\n      assertArgument(result.isSigned(), \"unsigned transaction cannot define from\", \"tx\", tx);\n      assertArgument(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["getAddress","ZeroAddress","keccak256","Signature","SigningKey","concat","decodeRlp","encodeRlp","getBytes","getBigInt","getNumber","hexlify","assert","assertArgument","isHexString","toBeArray","zeroPadValue","accessListify","recoverAddress","BN_0","BigInt","BN_2","BN_27","BN_28","BN_35","BN_MAX_UINT","handleAddress","value","handleAccessList","param","error","message","handleNumber","_value","handleUint","formatNumber","name","result","length","formatAccessList","map","set","address","storageKeys","formatHashes","Array","isArray","i","_parseLegacy","data","fields","tx","type","nonce","gasPrice","gasLimit","to","chainId","v","r","s","signature","from","hash","_serializeLegacy","sig","networkV","legacyChainId","legacy","push","yParity","getChainIdV","_parseEipSignature","Error","_parseEip1559","slice","maxPriorityFeePerGas","maxFeePerGas","accessList","_serializeEip1559","_parseEip2930","_serializeEip2930","_parseEip4844","maxFeePerBlobGas","blobVersionedHashes","_serializeEip4844","Transaction","typeName","constructor","serialized","unsignedHash","unsignedSerialized","fromPublicKey","recoverPublicKey","isSigned","operation","inferType","types","inferTypes","indexOf","pop","hasGasPrice","hasFee","hasAccessList","hasBlob","sort","isLegacy","isBerlin","isLondon","isCancun","clone","toJSON","toString","payload","toLowerCase"],"sources":["C:\\project\\fiverr-clone\\client\\node_modules\\ethers\\src.ts\\transaction\\transaction.ts"],"sourcesContent":["\nimport { getAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/addresses.js\";\nimport { keccak256, Signature, SigningKey } from \"../crypto/index.js\";\nimport {\n    concat, decodeRlp, encodeRlp, getBytes, getBigInt, getNumber, hexlify,\n    assert, assertArgument, isHexString, toBeArray, zeroPadValue\n} from \"../utils/index.js\";\n\nimport { accessListify } from \"./accesslist.js\";\nimport { recoverAddress } from \"./address.js\";\n\nimport type { BigNumberish, BytesLike } from \"../utils/index.js\";\nimport type { SignatureLike } from \"../crypto/index.js\";\n\nimport type { AccessList, AccessListish } from \"./index.js\";\n\n\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27)\nconst BN_28 = BigInt(28)\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\n\n/**\n *  A **TransactionLike** is an object which is appropriate as a loose\n *  input for many operations which will populate missing properties of\n *  a transaction.\n */\nexport interface TransactionLike<A = string> {\n    /**\n     *  The type.\n     */\n    type?: null | number;\n\n    /**\n     *  The recipient address or ``null`` for an ``init`` transaction.\n     */\n    to?: null | A;\n\n    /**\n     *  The sender.\n     */\n    from?: null | A;\n\n    /**\n     *  The nonce.\n     */\n    nonce?: null | number;\n\n    /**\n     *  The maximum amount of gas that can be used.\n     */\n    gasLimit?: null | BigNumberish;\n\n    /**\n     *  The gas price for legacy and berlin transactions.\n     */\n    gasPrice?: null | BigNumberish;\n\n    /**\n     *  The maximum priority fee per gas for london transactions.\n     */\n    maxPriorityFeePerGas?: null | BigNumberish;\n\n    /**\n     *  The maximum total fee per gas for london transactions.\n     */\n    maxFeePerGas?: null | BigNumberish;\n\n    /**\n     *  The data.\n     */\n    data?: null | string;\n\n    /**\n     *  The value (in wei) to send.\n     */\n    value?: null | BigNumberish;\n\n    /**\n     *  The chain ID the transaction is valid on.\n     */\n    chainId?: null | BigNumberish;\n\n    /**\n     *  The transaction hash.\n     */\n    hash?: null | string;\n\n    /**\n     *  The signature provided by the sender.\n     */\n    signature?: null | SignatureLike;\n\n    /**\n     *  The access list for berlin and london transactions.\n     */\n    accessList?: null | AccessListish;\n\n    /**\n     *  The maximum fee per blob gas (see [[link-eip-4844]]).\n     */\n    maxFeePerBlobGas?: null | BigNumberish;\n\n    /**\n     *  The versioned hashes (see [[link-eip-4844]]).\n     */\n    blobVersionedHashes?: null | Array<string>;\n}\n\nfunction handleAddress(value: string): null | string {\n    if (value === \"0x\") { return null; }\n    return getAddress(value);\n}\n\nfunction handleAccessList(value: any, param: string): AccessList {\n    try {\n        return accessListify(value);\n    } catch (error: any) {\n        assertArgument(false, error.message, param, value);\n    }\n}\n\nfunction handleNumber(_value: string, param: string): number {\n    if (_value === \"0x\") { return 0; }\n    return getNumber(_value, param);\n}\n\nfunction handleUint(_value: string, param: string): bigint {\n    if (_value === \"0x\") { return BN_0; }\n    const value = getBigInt(_value, param);\n    assertArgument(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n    return value;\n}\n\nfunction formatNumber(_value: BigNumberish, name: string): Uint8Array {\n    const value = getBigInt(_value, \"value\");\n    const result = toBeArray(value);\n    assertArgument(result.length <= 32, `value too large`, `tx.${ name }`, value);\n    return result;\n}\n\nfunction formatAccessList(value: AccessListish): Array<[ string, Array<string> ]> {\n    return accessListify(value).map((set) => [ set.address, set.storageKeys ]);\n}\n\nfunction formatHashes(value: Array<string>, param: string): Array<string> {\n    assertArgument(Array.isArray(value), `invalid ${ param }`, \"value\", value);\n    for (let i = 0; i < value.length; i++) {\n        assertArgument(isHexString(value[i], 32), \"invalid ${ param } hash\", `value[${ i }]`, value[i]);\n    }\n    return value;\n}\n\nfunction _parseLegacy(data: Uint8Array): TransactionLike {\n    const fields: any = decodeRlp(data);\n\n    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6),\n        \"invalid field count for legacy transaction\", \"data\", data);\n\n    const tx: TransactionLike = {\n        type:     0,\n        nonce:    handleNumber(fields[0], \"nonce\"),\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\n        to:       handleAddress(fields[3]),\n        value:    handleUint(fields[4], \"value\"),\n        data:     hexlify(fields[5]),\n        chainId:  BN_0\n    };\n\n    // Legacy unsigned transaction\n    if (fields.length === 6) { return tx; }\n\n    const v = handleUint(fields[6], \"v\");\n    const r = handleUint(fields[7], \"r\");\n    const s = handleUint(fields[8], \"s\");\n\n    if (r === BN_0 && s === BN_0) {\n        // EIP-155 unsigned transaction\n        tx.chainId = v;\n\n    } else {\n\n        // Compute the EIP-155 chain ID (or 0 for legacy)\n        let chainId = (v - BN_35) / BN_2;\n        if (chainId < BN_0) { chainId = BN_0; }\n        tx.chainId = chainId\n\n        // Signed Legacy Transaction\n        assertArgument(chainId !== BN_0 || (v === BN_27 || v === BN_28), \"non-canonical legacy v\", \"v\", fields[6]);\n\n        tx.signature = Signature.from({\n            r: zeroPadValue(fields[7], 32),\n            s: zeroPadValue(fields[8], 32),\n            v\n        });\n\n        tx.hash = keccak256(data);\n    }\n\n    return tx;\n}\n\nfunction _serializeLegacy(tx: Transaction, sig?: Signature): string {\n    const fields: Array<any> = [\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n    ];\n\n    let chainId = BN_0;\n    if (tx.chainId != BN_0) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = getBigInt(tx.chainId, \"tx.chainId\");\n\n        // We have a chainId in the tx and an EIP-155 v in the signature,\n        // make sure they agree with each other\n        assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId,\n             \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n\n    } else if (tx.signature) {\n        // No explicit chainId, but EIP-155 have a derived implicit chainId\n        const legacy = tx.signature.legacyChainId;\n        if (legacy != null) { chainId = legacy; }\n    }\n\n    // Requesting an unsigned transaction\n    if (!sig) {\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\n        if (chainId !== BN_0) {\n            fields.push(toBeArray(chainId));\n            fields.push(\"0x\");\n            fields.push(\"0x\");\n        }\n\n        return encodeRlp(fields);\n    }\n\n    // @TODO: We should probably check that tx.signature, chainId, and sig\n    //        match but that logic could break existing code, so schedule\n    //        this for the next major bump.\n\n    // Compute the EIP-155 v\n    let v = BigInt(27 + sig.yParity);\n    if (chainId !== BN_0) {\n        v = Signature.getChainIdV(chainId, sig.v);\n    } else if (BigInt(sig.v) !== v) {\n        assertArgument(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n\n    // Add the signature\n    fields.push(toBeArray(v));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n\n    return encodeRlp(fields);\n}\n\nfunction _parseEipSignature(tx: TransactionLike, fields: Array<string>): void {\n    let yParity: number;\n    try {\n        yParity = handleNumber(fields[0], \"yParity\");\n        if (yParity !== 0 && yParity !== 1) { throw new Error(\"bad yParity\"); }\n    } catch (error) {\n        assertArgument(false, \"invalid yParity\", \"yParity\", fields[0]);\n    }\n\n    const r = zeroPadValue(fields[1], 32);\n    const s = zeroPadValue(fields[2], 32);\n\n    const signature = Signature.from({ r, s, yParity });\n    tx.signature = signature;\n}\n\nfunction _parseEip1559(data: Uint8Array): TransactionLike {\n    const fields: any = decodeRlp(getBytes(data).slice(1));\n\n    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12),\n        \"invalid field count for transaction type: 2\", \"data\", hexlify(data));\n\n    const tx: TransactionLike = {\n        type:                  2,\n        chainId:               handleUint(fields[0], \"chainId\"),\n        nonce:                 handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas:  handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas:          handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice:              null,\n        gasLimit:              handleUint(fields[4], \"gasLimit\"),\n        to:                    handleAddress(fields[5]),\n        value:                 handleUint(fields[6], \"value\"),\n        data:                  hexlify(fields[7]),\n        accessList:            handleAccessList(fields[8], \"accessList\"),\n    };\n\n    // Unsigned EIP-1559 Transaction\n    if (fields.length === 9) { return tx; }\n\n    tx.hash = keccak256(data);\n\n    _parseEipSignature(tx, fields.slice(9));\n\n    return tx;\n}\n\nfunction _serializeEip1559(tx: Transaction, sig?: Signature): string {\n    const fields: Array<any> = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [ ])\n    ];\n\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n    }\n\n    return concat([ \"0x02\", encodeRlp(fields)]);\n}\n\nfunction _parseEip2930(data: Uint8Array): TransactionLike {\n    const fields: any = decodeRlp(getBytes(data).slice(1));\n\n    assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11),\n        \"invalid field count for transaction type: 1\", \"data\", hexlify(data));\n\n    const tx: TransactionLike = {\n        type:       1,\n        chainId:    handleUint(fields[0], \"chainId\"),\n        nonce:      handleNumber(fields[1], \"nonce\"),\n        gasPrice:   handleUint(fields[2], \"gasPrice\"),\n        gasLimit:   handleUint(fields[3], \"gasLimit\"),\n        to:         handleAddress(fields[4]),\n        value:      handleUint(fields[5], \"value\"),\n        data:       hexlify(fields[6]),\n        accessList: handleAccessList(fields[7], \"accessList\")\n    };\n\n    // Unsigned EIP-2930 Transaction\n    if (fields.length === 8) { return tx; }\n\n    tx.hash = keccak256(data);\n\n    _parseEipSignature(tx, fields.slice(8));\n\n    return tx;\n}\n\nfunction _serializeEip2930(tx: Transaction, sig?: Signature): string {\n    const fields: any = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [ ])\n    ];\n\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n    }\n\n    return concat([ \"0x01\", encodeRlp(fields)]);\n}\n\nfunction _parseEip4844(data: Uint8Array): TransactionLike {\n    const fields: any = decodeRlp(getBytes(data).slice(1));\n\n    assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14),\n        \"invalid field count for transaction type: 3\", \"data\", hexlify(data));\n\n    const tx: TransactionLike = {\n        type:                  3,\n        chainId:               handleUint(fields[0], \"chainId\"),\n        nonce:                 handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas:  handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas:          handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice:              null,\n        gasLimit:              handleUint(fields[4], \"gasLimit\"),\n        to:                    handleAddress(fields[5]),\n        value:                 handleUint(fields[6], \"value\"),\n        data:                  hexlify(fields[7]),\n        accessList:            handleAccessList(fields[8], \"accessList\"),\n        maxFeePerBlobGas:      handleUint(fields[9], \"maxFeePerBlobGas\"),\n        blobVersionedHashes:   fields[10]\n    };\n\n    assertArgument(tx.to != null, \"invalid address for transaction type: 3\", \"data\", data);\n\n    assertArgument(Array.isArray(tx.blobVersionedHashes), \"invalid blobVersionedHashes: must be an array\", \"data\", data);\n    for (let i = 0; i < tx.blobVersionedHashes.length; i++) {\n        assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${ i }: must be length 32`, \"data\", data);\n    }\n\n    // Unsigned EIP-4844 Transaction\n    if (fields.length === 11) { return tx; }\n\n    tx.hash = keccak256(data);\n\n    _parseEipSignature(tx, fields.slice(11));\n\n    return tx;\n}\n\nfunction _serializeEip4844(tx: Transaction, sig?: Signature): string {\n    const fields: Array<any> = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || ZeroAddress),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [ ]),\n        formatNumber(tx.maxFeePerBlobGas || 0, \"maxFeePerBlobGas\"),\n        formatHashes(tx.blobVersionedHashes || [ ], \"blobVersionedHashes\")\n    ];\n\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n    }\n\n    return concat([ \"0x03\", encodeRlp(fields)]);\n}\n\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */\nexport class Transaction implements TransactionLike<string> {\n    #type: null | number;\n    #to: null | string;\n    #data: string;\n    #nonce: number;\n    #gasLimit: bigint;\n    #gasPrice: null | bigint;\n    #maxPriorityFeePerGas: null | bigint;\n    #maxFeePerGas: null | bigint;\n    #value: bigint;\n    #chainId: bigint;\n    #sig: null | Signature;\n    #accessList: null | AccessList;\n    #maxFeePerBlobGas: null | bigint;\n    #blobVersionedHashes: null | Array<string>;\n\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */\n    get type(): null | number { return this.#type; }\n    set type(value: null | number | string) {\n        switch (value) {\n            case null:\n                this.#type = null;\n                break;\n            case 0: case \"legacy\":\n                this.#type = 0;\n                break;\n            case 1: case \"berlin\": case \"eip-2930\":\n                this.#type = 1;\n                break;\n            case 2: case \"london\": case \"eip-1559\":\n                this.#type = 2;\n                break;\n            case 3: case \"cancun\": case \"eip-4844\":\n                this.#type = 3;\n                break;\n            default:\n                assertArgument(false, \"unsupported transaction type\", \"type\", value);\n        }\n    }\n\n    /**\n     *  The name of the transaction type.\n     */\n    get typeName(): null | string {\n        switch (this.type) {\n            case 0: return \"legacy\";\n            case 1: return \"eip-2930\";\n            case 2: return \"eip-1559\";\n            case 3: return \"eip-4844\";\n        }\n\n        return null;\n    }\n\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */\n    get to(): null | string {\n        const value = this.#to;\n        if (value == null && this.type === 3) { return ZeroAddress; }\n        return value;\n    }\n    set to(value: null | string) {\n        this.#to = (value == null) ? null: getAddress(value);\n    }\n\n    /**\n     *  The transaction nonce.\n     */\n    get nonce(): number { return this.#nonce; }\n    set nonce(value: BigNumberish) { this.#nonce = getNumber(value, \"value\"); }\n\n    /**\n     *  The gas limit.\n     */\n    get gasLimit(): bigint { return this.#gasLimit; }\n    set gasLimit(value: BigNumberish) { this.#gasLimit = getBigInt(value); }\n\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */\n    get gasPrice(): null | bigint {\n        const value = this.#gasPrice;\n        if (value == null && (this.type === 0 || this.type === 1)) { return BN_0; }\n        return value;\n    }\n    set gasPrice(value: null | BigNumberish) {\n        this.#gasPrice = (value == null) ? null: getBigInt(value, \"gasPrice\");\n    }\n\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxPriorityFeePerGas(): null | bigint {\n        const value = this.#maxPriorityFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) { return BN_0; }\n            return null;\n        }\n        return value;\n    }\n    set maxPriorityFeePerGas(value: null | BigNumberish) {\n        this.#maxPriorityFeePerGas = (value == null) ? null: getBigInt(value, \"maxPriorityFeePerGas\");\n    }\n\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxFeePerGas(): null | bigint {\n        const value = this.#maxFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) { return BN_0; }\n            return null;\n        }\n        return value;\n    }\n    set maxFeePerGas(value: null | BigNumberish) {\n        this.#maxFeePerGas = (value == null) ? null: getBigInt(value, \"maxFeePerGas\");\n    }\n\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */\n    get data(): string { return this.#data; }\n    set data(value: BytesLike) { this.#data = hexlify(value); }\n\n    /**\n     *  The amount of ether (in wei) to send in this transactions.\n     */\n    get value(): bigint { return this.#value; }\n    set value(value: BigNumberish) {\n        this.#value = getBigInt(value, \"value\");\n    }\n\n    /**\n     *  The chain ID this transaction is valid on.\n     */\n    get chainId(): bigint { return this.#chainId; }\n    set chainId(value: BigNumberish) { this.#chainId = getBigInt(value); }\n\n    /**\n     *  If signed, the signature for this transaction.\n     */\n    get signature(): null | Signature { return this.#sig || null; }\n    set signature(value: null | SignatureLike) {\n        this.#sig = (value == null) ? null: Signature.from(value);\n    }\n\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */\n    get accessList(): null | AccessList {\n        const value = this.#accessList || null;\n        if (value == null) {\n            if (this.type === 1 || this.type === 2 || this.type === 3) {\n                // @TODO: in v7, this should assign the value or become\n                // a live object itself, otherwise mutation is inconsistent\n                return [ ];\n            }\n            return null;\n        }\n        return value;\n    }\n    set accessList(value: null | AccessListish) {\n        this.#accessList = (value == null) ? null: accessListify(value);\n    }\n\n    /**\n     *  The max fee per blob gas for Cancun transactions.\n     */\n    get maxFeePerBlobGas(): null | bigint {\n        const value = this.#maxFeePerBlobGas;\n        if (value == null && this.type === 3) { return BN_0; }\n        return value;\n    }\n    set maxFeePerBlobGas(value: null | BigNumberish) {\n        this.#maxFeePerBlobGas = (value == null) ? null: getBigInt(value, \"maxFeePerBlobGas\");\n    }\n\n    /**\n     *  The BLOB versioned hashes for Cancun transactions.\n     */\n    get blobVersionedHashes(): null | Array<string> {\n        // @TODO: Mutation is inconsistent; if unset, the returned value\n        // cannot mutate the object, if set it can\n        let value = this.#blobVersionedHashes;\n        if (value == null && this.type === 3) { return [ ]; }\n        return value;\n    }\n    set blobVersionedHashes(value: null | Array<string>) {\n        if (value != null) {\n            assertArgument(Array.isArray(value), \"blobVersionedHashes must be an Array\", \"value\", value);\n            value = value.slice();\n            for (let i = 0; i < value.length; i++) {\n                assertArgument(isHexString(value[i], 32), \"invalid blobVersionedHash\", `value[${ i }]`, value[i]);\n            }\n        }\n        this.#blobVersionedHashes = value;\n    }\n\n    /**\n     *  Creates a new Transaction with default values.\n     */\n    constructor() {\n        this.#type = null;\n        this.#to = null;\n        this.#nonce = 0;\n        this.#gasLimit = BN_0;\n        this.#gasPrice = null;\n        this.#maxPriorityFeePerGas = null;\n        this.#maxFeePerGas = null;\n        this.#data = \"0x\";\n        this.#value = BN_0;\n        this.#chainId = BN_0;\n        this.#sig = null;\n        this.#accessList = null;\n        this.#maxFeePerBlobGas = null;\n        this.#blobVersionedHashes = null;\n    }\n\n    /**\n     *  The transaction hash, if signed. Otherwise, ``null``.\n     */\n    get hash(): null | string {\n        if (this.signature == null) { return null; }\n        return keccak256(this.serialized);\n    }\n\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */\n    get unsignedHash(): string {\n        return keccak256(this.unsignedSerialized);\n    }\n\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */\n    get from(): null | string {\n        if (this.signature == null) { return null; }\n        return recoverAddress(this.unsignedHash, this.signature);\n    }\n\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */\n    get fromPublicKey(): null | string {\n        if (this.signature == null) { return null; }\n        return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n    }\n\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */\n    isSigned(): this is (Transaction & { type: number, typeName: string, from: string, signature: Signature }) {\n        return this.signature != null;\n    }\n\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */\n    get serialized(): string {\n        assert(this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\"});\n\n        switch (this.inferType()) {\n            case 0:\n                return _serializeLegacy(this, this.signature);\n            case 1:\n                return _serializeEip2930(this, this.signature);\n            case 2:\n                return _serializeEip1559(this, this.signature);\n            case 3:\n                return _serializeEip4844(this, this.signature);\n        }\n\n        assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\n    }\n\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */\n    get unsignedSerialized(): string {\n        switch (this.inferType()) {\n            case 0:\n                return _serializeLegacy(this);\n            case 1:\n                return _serializeEip2930(this);\n            case 2:\n                return _serializeEip1559(this);\n            case 3:\n                return _serializeEip4844(this);\n        }\n\n        assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \".unsignedSerialized\" });\n    }\n\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */\n    inferType(): number {\n        const types = this.inferTypes();\n\n        // Prefer London (EIP-1559) over Cancun (BLOb)\n        if (types.indexOf(2) >= 0) { return 2; }\n\n        // Return the highest inferred type\n        return <number>(types.pop());\n    }\n\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */\n    inferTypes(): Array<number> {\n\n        // Checks that there are no conflicting properties set\n        const hasGasPrice = this.gasPrice != null;\n        const hasFee = (this.maxFeePerGas != null || this.maxPriorityFeePerGas != null);\n        const hasAccessList = (this.accessList != null);\n        const hasBlob = (this.#maxFeePerBlobGas != null || this.#blobVersionedHashes);\n\n        //if (hasGasPrice && hasFee) {\n        //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n        //}\n\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n            assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", { value: this });\n        }\n\n        //if (this.type === 2 && hasGasPrice) {\n        //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n        //}\n\n        assert(!hasFee || (this.type !== 0 && this.type !== 1), \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", { value: this });\n        assert(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", { value: this })\n\n        const types: Array<number> = [ ];\n\n        // Explicit type\n        if (this.type != null) {\n            types.push(this.type);\n\n        } else {\n            if (hasFee) {\n                types.push(2);\n            } else if (hasGasPrice) {\n                types.push(1);\n                if (!hasAccessList) { types.push(0); }\n            } else if (hasAccessList) {\n                types.push(1);\n                types.push(2);\n            } else if (hasBlob && this.to) {\n                types.push(3);\n            } else {\n                types.push(0);\n                types.push(1);\n                types.push(2);\n                types.push(3);\n            }\n        }\n\n        types.sort();\n\n        return types;\n    }\n\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLegacy(): this is (Transaction & { type: 0, gasPrice: bigint }) {\n        return (this.type === 0);\n    }\n\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isBerlin(): this is (Transaction & { type: 1, gasPrice: bigint, accessList: AccessList }) {\n        return (this.type === 1);\n    }\n\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLondon(): this is (Transaction & { type: 2, accessList: AccessList, maxFeePerGas: bigint, maxPriorityFeePerGas: bigint }) {\n        return (this.type === 2);\n    }\n\n    /**\n     *  Returns true if this transaction is an [[link-eip-4844]] BLOB\n     *  transaction.\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isCancun(): this is (Transaction & { type: 3, to: string, accessList: AccessList, maxFeePerGas: bigint, maxPriorityFeePerGas: bigint, maxFeePerBlobGas: bigint, blobVersionedHashes: Array<string> }) {\n        return (this.type === 3);\n    }\n\n    /**\n     *  Create a copy of this transaciton.\n     */\n    clone(): Transaction {\n        return Transaction.from(this);\n    }\n\n    /**\n     *  Return a JSON-friendly object.\n     */\n    toJSON(): any {\n        const s = (v: null | bigint) => {\n            if (v == null) { return null; }\n            return v.toString();\n        };\n\n        return {\n            type: this.type,\n            to: this.to,\n//            from: this.from,\n            data: this.data,\n            nonce: this.nonce,\n            gasLimit: s(this.gasLimit),\n            gasPrice: s(this.gasPrice),\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n            maxFeePerGas: s(this.maxFeePerGas),\n            value: s(this.value),\n            chainId: s(this.chainId),\n            sig: this.signature ? this.signature.toJSON(): null,\n            accessList: this.accessList\n        };\n    }\n\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */\n    static from(tx?: string | TransactionLike<string>): Transaction {\n        if (tx == null) { return new Transaction(); }\n\n        if (typeof(tx) === \"string\") {\n            const payload = getBytes(tx);\n\n            if (payload[0] >= 0x7f) { // @TODO: > vs >= ??\n                return Transaction.from(_parseLegacy(payload));\n            }\n\n            switch(payload[0]) {\n                case 1: return Transaction.from(_parseEip2930(payload));\n                case 2: return Transaction.from(_parseEip1559(payload));\n                case 3: return Transaction.from(_parseEip4844(payload));\n            }\n            assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \"from\" });\n        }\n\n        const result = new Transaction();\n        if (tx.type != null) { result.type = tx.type; }\n        if (tx.to != null) { result.to = tx.to; }\n        if (tx.nonce != null) { result.nonce = tx.nonce; }\n        if (tx.gasLimit != null) { result.gasLimit = tx.gasLimit; }\n        if (tx.gasPrice != null) { result.gasPrice = tx.gasPrice; }\n        if (tx.maxPriorityFeePerGas != null) { result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas; }\n        if (tx.maxFeePerGas != null) { result.maxFeePerGas = tx.maxFeePerGas; }\n        if (tx.maxFeePerBlobGas != null) { result.maxFeePerBlobGas = tx.maxFeePerBlobGas; }\n        if (tx.data != null) { result.data = tx.data; }\n        if (tx.value != null) { result.value = tx.value; }\n        if (tx.chainId != null) { result.chainId = tx.chainId; }\n        if (tx.signature != null) { result.signature = Signature.from(tx.signature); }\n        if (tx.accessList != null) { result.accessList = tx.accessList; }\n        if (tx.blobVersionedHashes != null) { result.blobVersionedHashes = tx.blobVersionedHashes; }\n\n        if (tx.hash != null) {\n            assertArgument(result.isSigned(), \"unsigned transaction cannot define hash\", \"tx\", tx);\n            assertArgument(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n        }\n\n        if (tx.from != null) {\n            assertArgument(result.isSigned(), \"unsigned transaction cannot define from\", \"tx\", tx);\n            assertArgument(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n        }\n\n        return result;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}